{"version":3,"sources":["webpack:///./node_modules/react-swipeable/es/index.js","webpack:///./src/lib/components/TouchableComponent.react.js"],"names":["console","log","swipeable","TouchableComponent","props","state","active","swipedTop","bind","swipedRight","swipedBottom","swipedLeft","isActive","setState","e","x","y","isFlick","velocity","touches","rect","target","getBoundingClientRect","t","push","clientX","left","clientY","top","children","id","className","setProps","updateActive","start_timestamp","timeStamp","end_timestamp","touchData","Component","defaultProps","propTypes","PropTypes","node","string","n_clicks","number","func"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+B;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,iDAAiD,QAAQ;AACzD,+DAA+D,0BAA0B,uDAAuD;AAChJ,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,WAAW,iBAAiB;AACjG;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,W;AACjD;AACA,wDAAwD;AACxD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,qBAAqB,QAAQ;AAC3F;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA,wEAAwE,QAAQ;AAChF,+DAA+D,0BAA0B,YAAY;AACrG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+CAA+C,iBAAiB,KAAK;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,WAAW,KAAK;AAC/E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW,0BAA0B;AAClF;AACA;AACA;AACA,6CAA6C,WAAW,6CAA6C;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW,6CAA6C;AACrG;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,2BAA2B,4CAAY,iBAAiB;AACxD,2BAA2B,4CAAY,iBAAiB;AACxD;AACA,0BAA0B,4CAAY,iBAAiB;AACvD,4CAA4C;AAC5C;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6CAAa,6HAA6H,aAAa;AAC3L;AACA;AACA;;AAE+C;AAC/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9QmC;AACI;AACG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,OAAO,CAACC,GAAG,CAAC,WAAW,EAAEC,yDAAS,CAAC;AAAC,IACfC,kBAAkB;EAAA;EAAA;EACnC,4BAAYC,KAAK,EAAE;IAAA;IAAA;IACf,0BAAMA,KAAK;IACX,MAAKC,KAAK,GAAG;MAACC,MAAM,EAAE;IAAK,CAAC;IAC5B,MAAKC,SAAS,GAAG,MAAKA,SAAS,CAACC,IAAI,+BAAM;IAC1C,MAAKC,WAAW,GAAG,MAAKA,WAAW,CAACD,IAAI,+BAAM;IAC9C,MAAKE,YAAY,GAAG,MAAKA,YAAY,CAACF,IAAI,+BAAM;IAChD,MAAKG,UAAU,GAAG,MAAKA,UAAU,CAACH,IAAI,+BAAM;IAAC;EACjD;EAAC;IAAA;IAAA,OACD,sBAAaI,QAAQ,EAAE;MACnB,IAAI,CAACC,QAAQ,CAAC;QAACP,MAAM,EAAEM;MAAQ,CAAC,CAAC;IACrC;EAAC;IAAA;IAAA,OACD,mBAAUE,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEC,QAAQ,EAAE;MAClClB,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEa,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEC,QAAQ,CAAC;IAC7D;EAAC;IAAA;IAAA,OACD,oBAAWJ,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEC,QAAQ,EAAE;MACnClB,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEa,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEC,QAAQ,CAAC;IAC9D;EAAC;IAAA;IAAA,OACD,sBAAaJ,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEC,QAAQ,EAAE;MACrClB,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAEa,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEC,QAAQ,CAAC;IAChE;EAAC;IAAA;IAAA,OACD,qBAAYJ,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEC,QAAQ,EAAE;MACpClB,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEa,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEC,QAAQ,CAAC;IAC/D;EAAC;IAAA;IAAA,OACD,mBAAUJ,CAAC,EAAE;MACT,IAAIK,OAAO,GAAG,EAAE;MAChB,IAAMC,IAAI,GAAGN,CAAC,CAACO,MAAM,CAACC,qBAAqB,EAAE;MAAC,2CAChCR,CAAC,CAACK,OAAO;QAAA;MAAA;QAAvB,oDAAyB;UAAA,IAAhBI,CAAC;UACNJ,OAAO,CAACK,IAAI,CAAC;YAACT,CAAC,EAAEQ,CAAC,CAACE,OAAO,GAAGL,IAAI,CAACM,IAAI;YAAEV,CAAC,EAAEO,CAAC,CAACI,OAAO,GAAGP,IAAI,CAACQ;UAAG,CAAC,CAAC;QACrE;MAAC;QAAA;MAAA;QAAA;MAAA;MACD5B,OAAO,CAACC,GAAG,CAACkB,OAAO,CAAC;MACpB,OAAOA,OAAO;IAClB;EAAC;IAAA;IAAA,OACD,kBAAS;MAAA;MACL,kBAA4C,IAAI,CAACf,KAAK;QAA/CyB,QAAQ,eAARA,QAAQ;QAAEC,EAAE,eAAFA,EAAE;QAAEC,SAAS,eAATA,SAAS;QAAEC,QAAQ,eAARA,QAAQ;MACxC,oBACI;QACI,EAAE,EAAEF,EAAG;QACP,SAAS,EAAEC,SAAS,IAAI,IAAI,CAAC1B,KAAK,CAACC,MAAM,GAAG,SAAS,GAAG,EAAE,CAAE;QAC5D,YAAY,EAAE,sBAACQ,CAAC,EAAK;UACjB,MAAI,CAACmB,YAAY,CAAC,IAAI,CAAC;UACvBD,QAAQ,CAAC;YAACE,eAAe,EAAEpB,CAAC,CAACqB;UAAS,CAAC,CAAC;QAC5C,CAAE;QACF,UAAU,EAAE,oBAACrB,CAAC,EAAK;UACf,MAAI,CAACmB,YAAY,CAAC,KAAK,CAAC;UACxBD,QAAQ,CAAC;YAACI,aAAa,EAAEtB,CAAC,CAACqB;UAAS,CAAC,CAAC;QAC1C,CAAE;QACF,WAAW,EAAE,qBAACrB,CAAC;UAAA,OAAKkB,QAAQ,CAAC;YAACb,OAAO,EAAE,MAAI,CAACkB,SAAS,CAACvB,CAAC;UAAC,CAAC,CAAC;QAAA,CAAC;QAC3D,OAAO,EAAE,iBAACA,CAAC;UAAA,OAAKkB,QAAQ,CAAC;YAACI,aAAa,EAAEtB,CAAC,CAACqB;UAAS,CAAC,CAAC;QAAA;MAAC,gBAEvD,2DAAC,SAAS;QACN,WAAW,EAAE,IAAI,CAAC5B,SAAU;QAC5B,YAAY,EAAE,IAAI,CAACI,UAAW;QAC9B,cAAc,EAAE,IAAI,CAACD,YAAa;QAClC,aAAa,EAAE,IAAI,CAACD;MAAY,GAE/BoB,QAAQ,CACD,CACV;IAEd;EAAC;EAAA;AAAA,EA5D2CS,+CAAS;AAAlB;AA+DvCnC,kBAAkB,CAACoC,YAAY,GAAG,CAAC,CAAC;AAEpCpC,kBAAkB,CAACqC,SAAS,GAAG;EAC3BX,QAAQ,EAAEY,iDAAS,CAACC,IAAI;EACxBZ,EAAE,EAAEW,iDAAS,CAACE,MAAM;EACpBZ,SAAS,EAAEU,iDAAS,CAACE,MAAM;EAC3BC,QAAQ,EAAEH,iDAAS,CAACI,MAAM;EAC1B;AACJ;AACA;AACA;EACIb,QAAQ,EAAES,iDAAS,CAACK;AACxB,CAAC,C","file":"20dd6a9-main-wps-hmr.js","sourcesContent":["import * as React from 'react';\n\nconst LEFT = \"Left\";\nconst RIGHT = \"Right\";\nconst UP = \"Up\";\nconst DOWN = \"Down\";\n\n/* global document */\nconst defaultProps = {\n    delta: 10,\n    preventScrollOnSwipe: false,\n    rotationAngle: 0,\n    trackMouse: false,\n    trackTouch: true,\n    swipeDuration: Infinity,\n    touchEventOptions: { passive: true },\n};\nconst initialState = {\n    first: true,\n    initial: [0, 0],\n    start: 0,\n    swiping: false,\n    xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\nfunction getDirection(absX, absY, deltaX, deltaY) {\n    if (absX > absY) {\n        if (deltaX > 0) {\n            return RIGHT;\n        }\n        return LEFT;\n    }\n    else if (deltaY > 0) {\n        return DOWN;\n    }\n    return UP;\n}\nfunction rotateXYByAngle(pos, angle) {\n    if (angle === 0)\n        return pos;\n    const angleInRadians = (Math.PI / 180) * angle;\n    const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n    const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n    return [x, y];\n}\nfunction getHandlers(set, handlerProps) {\n    const onStart = (event) => {\n        const isTouch = \"touches\" in event;\n        // if more than a single touch don't track, for now...\n        if (isTouch && event.touches.length > 1)\n            return;\n        set((state, props) => {\n            // setup mouse listeners on document to track swipe since swipe can leave container\n            if (props.trackMouse && !isTouch) {\n                document.addEventListener(mouseMove, onMove);\n                document.addEventListener(mouseUp, onUp);\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            props.onTouchStartOrOnMouseDown &&\n                props.onTouchStartOrOnMouseDown({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { initial: xy.slice(), xy, start: event.timeStamp || 0 });\n        });\n    };\n    const onMove = (event) => {\n        set((state, props) => {\n            const isTouch = \"touches\" in event;\n            // Discount a swipe if additional touches are present after\n            // a swipe has started.\n            if (isTouch && event.touches.length > 1) {\n                return state;\n            }\n            // if swipe has exceeded duration stop tracking\n            if (event.timeStamp - state.start > props.swipeDuration) {\n                return state.swiping ? Object.assign(Object.assign({}, state), { swiping: false }) : state;\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            const deltaX = x - state.xy[0];\n            const deltaY = y - state.xy[1];\n            const absX = Math.abs(deltaX);\n            const absY = Math.abs(deltaY);\n            const time = (event.timeStamp || 0) - state.start;\n            const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n            const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n            const dir = getDirection(absX, absY, deltaX, deltaY);\n            // if swipe is under delta and we have not started to track a swipe: skip update\n            const delta = typeof props.delta === \"number\"\n                ? props.delta\n                : props.delta[dir.toLowerCase()] ||\n                    defaultProps.delta;\n            if (absX < delta && absY < delta && !state.swiping)\n                return state;\n            const eventData = {\n                absX,\n                absY,\n                deltaX,\n                deltaY,\n                dir,\n                event,\n                first: state.first,\n                initial: state.initial,\n                velocity,\n                vxvy,\n            };\n            // call onSwipeStart if present and is first swipe event\n            eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n            // call onSwiping if present\n            props.onSwiping && props.onSwiping(eventData);\n            // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n            // so we can call preventDefault if needed\n            let cancelablePageSwipe = false;\n            if (props.onSwiping ||\n                props.onSwiped ||\n                props[`onSwiped${dir}`]) {\n                cancelablePageSwipe = true;\n            }\n            if (cancelablePageSwipe &&\n                props.preventScrollOnSwipe &&\n                props.trackTouch &&\n                event.cancelable) {\n                event.preventDefault();\n            }\n            return Object.assign(Object.assign({}, state), { \n                // first is now always false\n                first: false, eventData, swiping: true });\n        });\n    };\n    const onEnd = (event) => {\n        set((state, props) => {\n            let eventData;\n            if (state.swiping && state.eventData) {\n                // if swipe is less than duration fire swiped callbacks\n                if (event.timeStamp - state.start < props.swipeDuration) {\n                    eventData = Object.assign(Object.assign({}, state.eventData), { event });\n                    props.onSwiped && props.onSwiped(eventData);\n                    const onSwipedDir = props[`onSwiped${eventData.dir}`];\n                    onSwipedDir && onSwipedDir(eventData);\n                }\n            }\n            else {\n                props.onTap && props.onTap({ event });\n            }\n            props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { eventData });\n        });\n    };\n    const cleanUpMouse = () => {\n        // safe to just call removeEventListener\n        document.removeEventListener(mouseMove, onMove);\n        document.removeEventListener(mouseUp, onUp);\n    };\n    const onUp = (e) => {\n        cleanUpMouse();\n        onEnd(e);\n    };\n    /**\n     * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n     * - true => { passive: false }\n     * - false => { passive: true } // Default\n     *\n     * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n     *\n     * props.touchEventOptions can also be set for all touch event listeners,\n     * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n     * supersede and force passive to false.\n     *\n     */\n    const attachTouch = (el, props) => {\n        let cleanup = () => { };\n        if (el && el.addEventListener) {\n            const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);\n            // attach touch event listeners and handlers\n            const tls = [\n                [touchStart, onStart, baseOptions],\n                // preventScrollOnSwipe option supersedes touchEventOptions.passive\n                [\n                    touchMove,\n                    onMove,\n                    Object.assign(Object.assign({}, baseOptions), (props.preventScrollOnSwipe ? { passive: false } : {})),\n                ],\n                [touchEnd, onEnd, baseOptions],\n            ];\n            tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n            // return properly scoped cleanup method for removing listeners, options not required\n            cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n        }\n        return cleanup;\n    };\n    const onRef = (el) => {\n        // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n        // ignore null here\n        if (el === null)\n            return;\n        set((state, props) => {\n            // if the same DOM el as previous just return state\n            if (state.el === el)\n                return state;\n            const addState = {};\n            // if new DOM el clean up old DOM and reset cleanUpTouch\n            if (state.el && state.el !== el && state.cleanUpTouch) {\n                state.cleanUpTouch();\n                addState.cleanUpTouch = void 0;\n            }\n            // only attach if we want to track touch\n            if (props.trackTouch && el) {\n                addState.cleanUpTouch = attachTouch(el, props);\n            }\n            // store event attached DOM el for comparison, clean up, and re-attachment\n            return Object.assign(Object.assign(Object.assign({}, state), { el }), addState);\n        });\n    };\n    // set ref callback to attach touch event listeners\n    const output = {\n        ref: onRef,\n    };\n    // if track mouse attach mouse down listener\n    if (handlerProps.trackMouse) {\n        output.onMouseDown = onStart;\n    }\n    return [output, attachTouch];\n}\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n    // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n    if (!props.trackTouch || !state.el) {\n        if (state.cleanUpTouch) {\n            state.cleanUpTouch();\n        }\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: undefined });\n    }\n    // trackTouch is on, so if there are no handlers attached, attach them and exit\n    if (!state.cleanUpTouch) {\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n    // remove and reattach handlers (this is required to update the passive option when attaching\n    // the handlers)\n    if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n        props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n        state.cleanUpTouch();\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    return state;\n}\nfunction useSwipeable(options) {\n    const { trackMouse } = options;\n    const transientState = React.useRef(Object.assign({}, initialState));\n    const transientProps = React.useRef(Object.assign({}, defaultProps));\n    // track previous rendered props\n    const previousProps = React.useRef(Object.assign({}, transientProps.current));\n    previousProps.current = Object.assign({}, transientProps.current);\n    // update current render props & defaults\n    transientProps.current = Object.assign(Object.assign({}, defaultProps), options);\n    // Force defaults for config properties\n    let defaultKey;\n    for (defaultKey in defaultProps) {\n        if (transientProps.current[defaultKey] === void 0) {\n            transientProps.current[defaultKey] = defaultProps[defaultKey];\n        }\n    }\n    const [handlers, attachTouch] = React.useMemo(() => getHandlers((stateSetter) => (transientState.current = stateSetter(transientState.current, transientProps.current)), { trackMouse }), [trackMouse]);\n    transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n    return handlers;\n}\n\nexport { DOWN, LEFT, RIGHT, UP, useSwipeable };\n//# sourceMappingURL=index.js.map\n","import PropTypes from 'prop-types';\r\nimport React, {Component} from 'react';\r\nimport {swipeable} from 'react-swipeable';\r\n/**\r\n * ExampleComponent is an example component.\r\n * It takes a property, `label`, and\r\n * displays it.\r\n * It renders an input with the property `value`\r\n * which is editable by the user.\r\n */\r\nconsole.log('Swipeable', swipeable);\r\nexport default class TouchableComponent extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {active: false};\r\n        this.swipedTop = this.swipedTop.bind(this);\r\n        this.swipedRight = this.swipedRight.bind(this);\r\n        this.swipedBottom = this.swipedBottom.bind(this);\r\n        this.swipedLeft = this.swipedLeft.bind(this);\r\n    }\r\n    updateActive(isActive) {\r\n        this.setState({active: isActive});\r\n    }\r\n    swipedTop(e, x, y, isFlick, velocity) {\r\n        console.log('--- Swiped Top', e, x, y, isFlick, velocity);\r\n    }\r\n    swipedLeft(e, x, y, isFlick, velocity) {\r\n        console.log('--- Swiped Left', e, x, y, isFlick, velocity);\r\n    }\r\n    swipedBottom(e, x, y, isFlick, velocity) {\r\n        console.log('--- Swiped Bottom', e, x, y, isFlick, velocity);\r\n    }\r\n    swipedRight(e, x, y, isFlick, velocity) {\r\n        console.log('--- Swiped Right', e, x, y, isFlick, velocity);\r\n    }\r\n    touchData(e) {\r\n        let touches = [];\r\n        const rect = e.target.getBoundingClientRect();\r\n        for (let t of e.touches) {\r\n            touches.push({x: t.clientX - rect.left, y: t.clientY - rect.top});\r\n        }\r\n        console.log(touches);\r\n        return touches;\r\n    }\r\n    render() {\r\n        const {children, id, className, setProps} = this.props;\r\n        return (\r\n            <div\r\n                id={id}\r\n                className={className + (this.state.active ? ' active' : '')}\r\n                onTouchStart={(e) => {\r\n                    this.updateActive(true);\r\n                    setProps({start_timestamp: e.timeStamp});\r\n                }}\r\n                onTouchEnd={(e) => {\r\n                    this.updateActive(false);\r\n                    setProps({end_timestamp: e.timeStamp});\r\n                }}\r\n                onTouchMove={(e) => setProps({touches: this.touchData(e)})}\r\n                onClick={(e) => setProps({end_timestamp: e.timeStamp})}\r\n            >\r\n                <Swipeable\r\n                    onSwipedTop={this.swipedTop}\r\n                    onSwipedLeft={this.swipedLeft}\r\n                    onSwipedBottom={this.swipedBottom}\r\n                    onSwipedRight={this.swipedRight}\r\n                >\r\n                    {children}\r\n                </Swipeable>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nTouchableComponent.defaultProps = {};\r\n\r\nTouchableComponent.propTypes = {\r\n    children: PropTypes.node,\r\n    id: PropTypes.string,\r\n    className: PropTypes.string,\r\n    n_clicks: PropTypes.number,\r\n    /**\r\n     * Dash-assigned callback that should be called to report property changes\r\n     * to Dash, to make them available for callbacks.\r\n     */\r\n    setProps: PropTypes.func,\r\n};\r\n"],"sourceRoot":""}